# 智能指针

指针是一个很通用的概念，它表示一个保存了内存地址的变量，这个地址表示的是一个真正的值所在的内存地址。



而智能指针从另一方面来说是一种表现的类似于指针的数据结构，并且智能指针拥有额外的元数据和能力。



智能指针通常是通过结构体来实现的，与普通的结构体不同的是，智能指针需要实现 `Deref`和 `Drop`这两个traits。

`Deref`trait允许你像使用引用一样去使用智能指针的实例，或者让智能指针与其他的引用和智能指针一同工作。

`Drop` trait 允许你在智能指针离开作用域时自定义代码行为。



标准库中的3种智能指针：

- `Box<T>`，用于堆中的值
- `Rc<T>`，引用计数类型以用于允许多所有权
- `Ref<T>`和 `RefMut<T>` ，通过 `RefCell<T>`访问，这是一种强制借用规则发生在运行时而不是编译时的类型。



## `Box<T>` 指向堆中数据的智能指针



`Box`智能指针用于表示堆中的数据以外没有别的功能了（当然也没有别的开销了）

常用于以下几种情况：

- 在编译时不能确定其数据类型，但是你又想要使用该数据
- 用于大块的数据所有权转移，但是你不想要重复的复制其值时
- 只关心其数据类型实现的trait，不关系其具体类型时



### 如何使用Box

#### 语法

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

上面与直接声明 `let b = 5`的区别在于，使用Box时，我们的数据存在于“堆”内存空间中，随着变量b退出作用域，变量b本身被释放（智能指针，存在于栈中），而其指向堆的内存空间同样也被释放。



下面看一个必须要使用Box才能够被定义的类型



### 使用Box启用递归类型

在栈中存储的变量必须在编译时就需要知道其大小，由于递归类型的数据理论上可以是无限大的，如果不使用Box，那么Rust则无法计算其大小。



## 使用`Deref ` *trait*将智能指针当做普通引用一样对待

### 实现我们自己的智能指针

`Box<T>`最终是被定义为是一个 `tuple` 类型的结构体，所以我们也可以依照此方式定义我们的自己的 `MyBox`

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

```



# `Rc<T>` 

`Rc<T>`是 *Reference counting* 的简写。

省流：可以用来让一个值有多个 ownership，比如用于“图”数据结构。“边”通常会共同持有一个Node。



# `RefCell<T>`

省流：`RefCell<T>`可以让编译时的 borrow check 阶段转移到运行时中。

不过需要通过 `borrow`和 `borrow_mut`方法来获取引用（runtime borrow check!）。



# `Rc<T>`与 `RefCell<T>`结合

使用：`Rc<RefCell<T>>`来解决多ownership和不可变值的问题。



# 循环引用

![image-20240607184711739](https://picbed-1255660905.cos.ap-chengdu.myqcloud.com/doc/image-20240607184711739.png)

如上图所示，如果变量`a`, `b`离开作用域时被清除，但是由于形成了循环引用，则5， 10占用的内存空间永远无法被回收。

对于循环引用，我们应该使用 `RefCell<Weak<T>>`来声明。



### upgrade 与 downgrade

#### upgrade 

对于弱引用的值我们不能确定在访问它的时候它到底存在与否，所以我们必须要通过 `upgrade`方法来确定其值存在，该方法会返回一个 `Option<Rc<T>>`类型的值。

#### downgrade

调用 `Rc::downgrade`方法可以得到一个弱引用类型 `Weak<T>`的只能指针



<img src="https://picbed-1255660905.cos.ap-chengdu.myqcloud.com/doc/image-20240611110011311.png" alt="image-20240611110011311" style="zoom: 33%;" />
