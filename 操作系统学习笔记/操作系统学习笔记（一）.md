# 汇编的函数参数及返回值



# 函数调用约定

1. __cdecl
2. __stdcall
3. __fastcall



### 研究调用约定：



1. 传参方式：

栈、寄存器、栈+寄存器

2. 传参的顺序
3. 平栈的方式

```assembly
test(0x11, 0x22, 0x33);
006A141E push 33h
006A1420 push 22h
006A1422 push 11h
006A1424 call test(06A114Ah)
006A1429 add esp,0Ch
```

x86架构默认的调用方式 (**_cdecl**)

1. 传参方式：栈
2. 传参顺序，从右到左
3. 平栈的方式：外平栈

**__stdcall**

1. 传参方式：栈
2. 传参顺序，从右到左
3. 平栈的方式：内平栈

**__fastcall**

```assembly
test(0x11, 0x22, 0x33);
006A141E push 33h
006A1420 mov edx, 22h
006A1422 mov ecx, 11h
006A1424 call test(06A114Ah)
```

1. 传参方式：寄存器 + 栈
   1. x86架构中只有两个寄存器可以用于传参，且ecx是第一个，edx是第二个
   2. 参数个数 <= 2全部通过使用寄存器，ecx, edx
   3. 参数个数 > 2时，通过栈 + 寄存器传参，ecx, edx, 后面剩余的参数还是从右向左传参。
   4. 
2. 传参顺序，从右到左
3. 平栈的方式：内平栈





## 堆栈平衡

平栈

​	例如 main 函数中调用test

​	调用者来平栈 --> 外平栈  (main函数平栈)

​		call的下一条指令长这样子: add esp, 4

​	被调用者平栈 --> 内平栈  (test函数平栈)

​		ret 8 => ret + add esp, 8



## __cdcl

1. 是内平栈 
2. 取参数的顺序
   1. int test(int a, int b)到底a在栈顶还是b在栈顶？



